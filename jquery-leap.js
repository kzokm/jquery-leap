// Generated by CoffeeScript 1.8.0
(function() {
  var $, containsPosition, leapToClient;

  $ = jQuery;

  $('<style>').text('.leap-tip-cursor {' + 'width: 10px;' + 'height: 10px;' + 'margin-top: -5px;' + 'margin-left: -5px;' + 'border: 1px solid #000;' + '}').appendTo('head');

  Leap.Controller.plugin('jQuery', function(options) {
    var receivers, tipCursor;
    if (options["class"] == null) {
      options["class"] = 'leap-receiver';
    }
    if (options.event_type == null) {
      options.event_type = 'leap';
    }
    receivers = "." + options["class"] + ":visible";
    tipCursor = void 0;
    if (options.show_cursor) {
      $(function() {
        tipCursor = $('<div class=leap-tip-cursor>').css({
          position: 'absolute',
          display: 'block'
        }).appendTo('body');
        return tipCursor.moveTo = function(position) {
          return this.css({
            left: position[0].toFixed(),
            top: position[1].toFixed()
          });
        };
      });
    }
    $.fn.extend({
      leap: function(selector, callback) {
        var $target;
        if (typeof selector === 'function') {
          callback = arguments[0], selector = arguments[1];
        }
        $target = $(selector != null ? selector : this).addClass(options["class"]);
        if (callback != null) {
          $target.on(options.event_type, callback);
        }
        return this;
      }
    });
    return {
      frame: function(frame) {
        var clientPosition, frontmost, _ref;
        frontmost = void 0;
        frame.fingers.forEach(function(finger) {
          if (finger.extended) {
            if ((frontmost == null) || frontmost.stabilizedTipPosition[2] > finger.stabilizedTipPosition[2]) {
              return frontmost = finger;
            }
          }
        });
        if (frontmost) {
          clientPosition = (_ref = options.calibrator) != null ? _ref.convert(frontmost.stabilizedTipPosition) : void 0;
          if (clientPosition == null) {
            clientPosition = leapToClient(frame, frontmost.stabilizedTipPosition);
          }
          if (tipCursor != null) {
            tipCursor.moveTo(clientPosition).show();
          }
          return $(receivers).each(function() {
            if (containsPosition(this, clientPosition)) {
              return $(this).trigger({
                type: options.event_type,
                clientX: clientPosition[0].toFixed(),
                clientY: clientPosition[1].toFixed(),
                frame: frame,
                finger: frontmost
              });
            }
          });
        } else {
          return tipCursor != null ? tipCursor.hide() : void 0;
        }
      }
    };
  });

  leapToClient = function(frame, position) {
    var norm, screenPosition;
    norm = frame.interactionBox.normalizePoint(position);
    return screenPosition = [window.innerWidth * norm[0], window.innerHeight * (1 - norm[1])];
  };

  containsPosition = function(element, position) {
    var rect, x, y;
    x = position[0], y = position[1];
    rect = element.getBoundingClientRect();
    return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
  };

}).call(this);
